(defun parse_puzzle_input (fp)
  (with-open-file (in fp)
    (let* ((fresh_ingredients
            (do ((l (read-line in nil) (read-line in nil))
                 (fresh_ingredients (list)))
              ((= (length l) 0) fresh_ingredients)
              (let* ((delimeter (position #\- l))
                     (sid (subseq l 0 delimeter))
                     (eid (subseq l (+ delimeter 1) (length l))))
                (push (list (parse-integer sid) (parse-integer eid)) fresh_ingredients))))
          (inventory
            (do ((l (read-line in nil) (read-line in nil))
                 (inventory (list)))
              ((null l) inventory)
              (push (parse-integer l) inventory))))
      (values (reverse fresh_ingredients) inventory))))

(defun calc_fresh_ingredients (fresh inventory)
  (do ((i 0 (+ i 1))
       (fresh_items (list)))
    ((>= i (length inventory)) fresh_items)
    (let ((inventory_item (elt inventory i)))
      (do ((f 0 (+ f 1)))
        ((>= f (length fresh)))
        (destructuring-bind (from to) (elt fresh f)
          (when (and (>= inventory_item from) (<= inventory_item to))
            (push inventory_item fresh_items)
            (return)))))))

(defun contains_inclusive (p1 p2 x)
  (and (>= x p1) (<= x p2)))

(defun merge_ranges (p1 ranges)
  (let ((from (elt p1 0))
        (to (elt p1 1))
        (rest (list)))
    (do ((i 0 (+ i 1)))
        ((>= i (length ranges)) (values (list from to) (reverse rest)))
        (destructuring-bind (from2 to2) (elt ranges i)
          (cond ((or (contains_inclusive from to from2) (contains_inclusive from to to2))
                  (setf to (max to to2))
                  (setf from (min from from2)))
                ((or (contains_inclusive from2 to2 from) (contains_inclusive from2 to2 to))
                  (setf to to2)
                  (setf from from2))
                (t (push (list from2 to2) rest)))))))

(defun calc_amount_of_fresh_ingredients (ranges)
  (do ((sum 0))
    ((= (length ranges) 0) sum)
    (do ((first_r (elt ranges 0))
         (rest (subseq ranges 1 (length ranges)))
         (curr_len -1)
         (prev_len -2))
      ((= 0 1))
      (multiple-value-bind (new_r new_rest) (merge_ranges first_r rest)
        (setf curr_len (length new_rest))
        (when (= prev_len curr_len)
          (let ((x1 (elt new_r 0))
                (x2 (elt new_r 1)))
            (incf sum (- x2 x1 -1))
            (setf ranges rest)
            (return)))
        (setf first_r new_r)
        (setf rest new_rest)
        (setf prev_len curr_len)))))

(multiple-value-bind (fresh inventory) (parse_puzzle_input "./input5.txt")
  (format t "answer part 1: ~a~%" (length (calc_fresh_ingredients (copy-tree fresh) inventory)))
  (format t "answer part 2: ~a~%" (calc_amount_of_fresh_ingredients fresh)))
  
